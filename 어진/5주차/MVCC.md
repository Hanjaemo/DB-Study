 # MVCC
1. MVCC 등장 배경 / 설명   
2. postgreSQL - lost update 문제 및 해결방안  
3. mySQL에서 lost update 문제 및 해결방안

---

1. MVCC 등장 배경
- 동일한 데이터에 대한 read 작업과 write 작업이 동시에 실행될 경우, 한 작업이 실행되는 동안 다른 작업이 멈춰있게 되어 전체 처리량이 저하되고 성능 문제가 발생하였음 -> 이런 문제 해결하기 위해 MVCC 등장

- 특징
  - 데이터 읽기 시, 최근 커밋된 데이터만 읽음
  - read와 write 블록 방지 : MVCC는 read와 write 작업이 서로를 블록하지 않음 -> 그로 인해 lock 기반 동시성 제어에 비해 더 뛰어난 성능 효과 有
  - 오늘날 대부분의 RDBMS는 MVCC 기반으로 동작함

- 장점
  - 데이터를 읽을 때, 특정 시점 기준으로 가장 최근에 commit된 데이터를 읽음
  - 데이터 변화(write) 이력 관리
  - read와 write는 서로를 block하지 않음
---



2. postgreSQL에서lost update 문제 및 해결 방안 : [요약](#lost-update-개념-설명)
> lost update : DB에서 두 개의 트랜잭션이 동시에 같은 데이터를 업데이트할 때 발생하는 현상
> 데이터의 일관성 붕괴, 예상치 못한 결과 초래 有
> 예제를 통해 설명  

✔️모든 트랜잭션이 read commited인 경우, lost update 발생  
👉초기값 : x = 50, y = 10 / 트랜잭션 1 : x가 y에 40을 이체한다 / 트랜잭션 2 : x에 30을 입금한다
🎲**기대값 : x = 40, y = 50이 되어야 함**
![image](https://github.com/mithzinf/DB-Study/assets/124668883/b951c489-c55b-45c5-9df8-ae8c004b7465)    
1) 먼저 트랜잭션 1이 실행하여 x값을 읽고("umm.. x값이 현재 50이군"), y에 40을 이체하기 위해 x값을 10으로 변경해준다(write(x=10))  
   이때, MVCC로 동작하기 때문에 가상의 공간을 만들어 두고 그 안에 x = 10값을 넣어놓음  
2) 트랜잭션 2도 실행하여, x에 30을 입금해야하므로 현재의 x값을 읽어준다  
3) 현재 commit된 x의 값은 50이기 때문에 (x = 10이라는 값은 오롯이 트랜잭션 1의 가상 공간에 저장된 값이고 commit이 되어 있지 않기 때문에 영향 미치지 x) 트랜잭션 2는 x의 값을 50으로 읽어옴  
4) x+30이라는 트랜잭션 2의 연산에 의해 write(x = 80) 실행 > 실행하기 위해서는, 먼저 x에 대한 write_lock을 선취득해야함   
   ![image](https://github.com/mithzinf/DB-Study/assets/124668883/fa73317e-296e-4fd7-b0d7-26c2baa53abe)  

5) BUT x에 대한 write_lock은 트랜잭션 1이 보유하고 있는 상황이기 때문에, 트랜잭션 1의 write_lock이 해제가 될 때까지 트랜잭션 2는 기다려야 함(가마니 상태)
6) 그런 상태에서, 트랜잭션1은 못다한 작업(y에 40을 더해주는 작업)을 다시 진행하게 됨
7) y에 40을 더해주는 작업을 실행하기 위해, 먼저 y의 값을 읽어준다 : read(y) = 10
8) y값을 읽은 후, y에 40을 더해주기 위해 write(y=50) 작업을 실행하기 위해서 먼저 y에 대한 write_lock(y)을 취득해야함
9) write_lock(y) 취득한 후, 트랜잭션1 내 가상 공간에 y = 50값을 넣어놓음  
![image](https://github.com/mithzinf/DB-Study/assets/124668883/5974276f-6444-475a-a587-b5e6c41a5054)  
10) 트랜잭션1에서 해야할 작업은 다 마쳤기 때문에, 트랜잭션1은 commit을 실행함 & 트랜잭션1의 가상 공간에 저장되어 있던 x,y값은 실제로 DB상에 저장됨 : **x = 10, y = 50**
11) write_lock을 기다리고 있던 트랜잭션2는 write_lock을 획득함 *마참내...* & 트랜잭션 초기에 진행하려다가 말았던 write(x = 80) 실행하게 됨
12) 트랜잭션 1때와 동일하게, 트랜잭션 2 또한 MVCC로 동작하기 때문에 트랜잭션 2만의 가상 공간을 만든 후 그 안에 x = 80 값을 넣어놓음
13) 그 다음 트랜잭션 2 commit 실행하게 되면, 트랜잭션 2의 가상공간에 저장되어 있던 x = 80값이 DB에 실제로 저장되므로 x와 y값은 다음과 같이 변한다 **최종 결과 : x = 80, y = 50**
14) 최종적으로 write_lock은 commit 등판과 동시에 사라지게 된다


## lost update 개념 설명
기대값 : x = 40, y = 50  
결과값 : x = 80, y = 50으로   
이처럼 기대값과 다른 결과값이 나온 경우를 **lost update** 라고 함
    




